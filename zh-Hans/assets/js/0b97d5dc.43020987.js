"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3964],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>u});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var d=n.createContext({}),o=function(t){var e=n.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=o(t.components);return n.createElement(d.Provider,{value:e},t.children)},k={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},s=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,d=t.parentName,m=p(t,["components","mdxType","originalType","parentName"]),s=o(a),u=r,N=s["".concat(d,".").concat(u)]||s[u]||k[u]||l;return a?n.createElement(N,i(i({ref:e},m),{},{components:a})):n.createElement(N,i({ref:e},m))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=s;var p={};for(var d in e)hasOwnProperty.call(e,d)&&(p[d]=e[d]);p.originalType=t,p.mdxType="string"==typeof t?t:r,i[1]=p;for(var o=2;o<l;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"},8010:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>k,frontMatter:()=>l,metadata:()=>p,toc:()=>o});var n=a(7462),r=(a(7294),a(3905));const l={layout:"post",title:"nftables\uff1anft man\u6587\u6863\u9605\u8bfb\u7b14\u8bb0",description:"\u8fd9\u91cc\u662f\u4e00\u4efdnft man\u6587\u6863\u7b14\u8bb0",categories:["system"],tags:["nft","nftables"]},i=void 0,p={permalink:"/notes/zh-Hans/blog/2017/06/13/nftables-man-page",editUrl:"https://github.com/itxx00/notes/tree/main/packages/create-docusaurus/templates/shared/blog/2017-06-13-nftables-man-page.md",source:"@site/blog/2017-06-13-nftables-man-page.md",title:"nftables\uff1anft man\u6587\u6863\u9605\u8bfb\u7b14\u8bb0",description:"\u8fd9\u91cc\u662f\u4e00\u4efdnft man\u6587\u6863\u7b14\u8bb0",date:"2017-06-13T00:00:00.000Z",formattedDate:"2017\u5e746\u670813\u65e5",tags:[{label:"nft",permalink:"/notes/zh-Hans/blog/tags/nft"},{label:"nftables",permalink:"/notes/zh-Hans/blog/tags/nftables"}],readingTime:47.36,hasTruncateMarker:!1,authors:[],frontMatter:{layout:"post",title:"nftables\uff1anft man\u6587\u6863\u9605\u8bfb\u7b14\u8bb0",description:"\u8fd9\u91cc\u662f\u4e00\u4efdnft man\u6587\u6863\u7b14\u8bb0",categories:["system"],tags:["nft","nftables"]},prevItem:{title:"k8s\u6d4b\u8bd5\u73af\u5883\u90e8\u7f72\u8bb0\u5f55",permalink:"/notes/zh-Hans/blog/2017/08/18/deploy-k8s-from-local-repo"},nextItem:{title:"\u5f00\u7bc7",permalink:"/notes/zh-Hans/blog/2017/05/31/first-post"}},d={authorsImageUrls:[]},o=[{value:"\u5de5\u5177\u540d\u79f0",id:"\u5de5\u5177\u540d\u79f0",level:2},{value:"\u57fa\u672c\u7528\u6cd5",id:"\u57fa\u672c\u7528\u6cd5",level:2},{value:"\u5de5\u5177\u63cf\u8ff0",id:"\u5de5\u5177\u63cf\u8ff0",level:2},{value:"\u9009\u9879\u8bf4\u660e",id:"\u9009\u9879\u8bf4\u660e",level:2},{value:"\u6587\u4ef6\u683c\u5f0f",id:"\u6587\u4ef6\u683c\u5f0f",level:2},{value:"\u8bed\u6cd5\u89c4\u5b9a",id:"\u8bed\u6cd5\u89c4\u5b9a",level:3},{value:"\u6587\u4ef6\u5f15\u7528",id:"\u6587\u4ef6\u5f15\u7528",level:3},{value:"\u7b26\u53f7\u53d8\u91cf",id:"\u7b26\u53f7\u53d8\u91cf",level:3},{value:"\u5730\u5740\u65cf",id:"\u5730\u5740\u65cf",level:2},{value:"IPv4/IPv6/Inet address families",id:"ipv4ipv6inet-address-families",level:3},{value:"ARP address family",id:"arp-address-family",level:3},{value:"Bridge address family",id:"bridge-address-family",level:3},{value:"Netdev address family",id:"netdev-address-family",level:3},{value:"Tables",id:"tables",level:2},{value:"Chains",id:"chains",level:2},{value:"Rules",id:"rules",level:2},{value:"Sets",id:"sets",level:2},{value:"Maps",id:"maps",level:2},{value:"Stateful objects",id:"stateful-objects",level:2},{value:"Ct",id:"ct",level:3},{value:"Counter",id:"counter",level:3},{value:"Quota",id:"quota",level:3},{value:"Expressions",id:"expressions",level:2},{value:"describe command",id:"describe-command",level:3},{value:"Data types",id:"data-types",level:2},{value:"Integer type",id:"integer-type",level:3},{value:"Bitmask type",id:"bitmask-type",level:3},{value:"String type",id:"string-type",level:3},{value:"Link layer address type",id:"link-layer-address-type",level:3},{value:"IPv4 address type",id:"ipv4-address-type",level:3},{value:"IPv6 address type",id:"ipv6-address-type",level:3},{value:"Boolean type",id:"boolean-type",level:3},{value:"ICMP Type type",id:"icmp-type-type",level:3},{value:"ICMPv6 Type type",id:"icmpv6-type-type",level:3},{value:"Primary expressions",id:"primary-expressions",level:2},{value:"Meta expressions",id:"meta-expressions",level:3},{value:"fib expressions",id:"fib-expressions",level:3},{value:"Routing expressions",id:"routing-expressions",level:3},{value:"Payload expressions",id:"payload-expressions",level:2},{value:"Ethernet header expression",id:"ethernet-header-expression",level:3},{value:"VLAN header expression",id:"vlan-header-expression",level:3},{value:"ARP header expression",id:"arp-header-expression",level:3},{value:"IPv4 header expression",id:"ipv4-header-expression",level:3},{value:"ICMP header expression",id:"icmp-header-expression",level:3},{value:"IPv6 header expression",id:"ipv6-header-expression",level:3},{value:"ICMPv6 header expression",id:"icmpv6-header-expression",level:3},{value:"TCP header expression",id:"tcp-header-expression",level:3},{value:"UDP header expression",id:"udp-header-expression",level:3},{value:"UDP-Lite header expression",id:"udp-lite-header-expression",level:3},{value:"SCTP header expression",id:"sctp-header-expression",level:3},{value:"DCCP header expression",id:"dccp-header-expression",level:3},{value:"Authentication header expression",id:"authentication-header-expression",level:3},{value:"Encrypted security payload header expression",id:"encrypted-security-payload-header-expression",level:3},{value:"IPcomp header expression",id:"ipcomp-header-expression",level:3},{value:"Extension header expressions",id:"extension-header-expressions",level:3},{value:"Conntrack expressions",id:"conntrack-expressions",level:3},{value:"Statements",id:"statements",level:2},{value:"Verdict statement",id:"verdict-statement",level:3},{value:"Payload statement",id:"payload-statement",level:3},{value:"Log statement",id:"log-statement",level:3},{value:"Reject statement",id:"reject-statement",level:3},{value:"Counter statement",id:"counter-statement",level:3},{value:"Conntrack statement",id:"conntrack-statement",level:3},{value:"Meta statement",id:"meta-statement",level:3},{value:"Limit statement",id:"limit-statement",level:3},{value:"NAT statements",id:"nat-statements",level:3},{value:"Queue statement",id:"queue-statement",level:3},{value:"Additional commands",id:"additional-commands",level:2},{value:"export",id:"export",level:3},{value:"monitor",id:"monitor",level:3},{value:"Error reporting",id:"error-reporting",level:2},{value:"\u9000\u51fa\u72b6\u6001\u7801",id:"\u9000\u51fa\u72b6\u6001\u7801",level:2},{value:"See Also",id:"see-also",level:2},{value:"Authors",id:"authors",level:2},{value:"Copyright",id:"copyright",level:2}],m={toc:o};function k(t){let{components:e,...a}=t;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u5229\u7528\u7a7a\u95f2\u65f6\u95f4\u5b66\u4e60\u4e86nftables\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u5176\u4e2d\u5b98\u65b9\u7684man page\u4e2d\u5305\u542b\u4e86\u5927\u91cf\u4fe1\u606f\uff0c\u5728\u9605\u8bfb\u8fc7\u7a0b\u4e2d\u6574\u7406\u4e86\u4e00\u4efd\u5e26\u4e2d\u6587\u6ce8\u91ca\u7684\u7b14\u8bb0\uff0c\u4ee5\u8f85\u52a9\u52a0\u6df1\u8bb0\u5fc6\u3002")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kramdown table of contents\n{:toc .toc}")),(0,r.kt)("h2",{id:"\u5de5\u5177\u540d\u79f0"},"\u5de5\u5177\u540d\u79f0"),(0,r.kt)("p",null,"nft\xa0--\xa0 \u5305\u8fc7\u6ee4\u89c4\u5219\u7ba1\u7406\u5de5\u5177"),(0,r.kt)("h2",{id:"\u57fa\u672c\u7528\u6cd5"},"\u57fa\u672c\u7528\u6cd5"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"nft [ -n | --numeric ] [ -s | --stateless ] [ [-I | --includepath] directory ] [ [-f | --file] filename | [-i | --interactive] | cmd ]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"nft [ -h | --help ] [ -v | --version ]")),(0,r.kt)("h2",{id:"\u5de5\u5177\u63cf\u8ff0"},"\u5de5\u5177\u63cf\u8ff0"),(0,r.kt)("p",null,"nftables \u4f5c\u4e3a\u65b0\u4e00\u4ee3\u7684\u9632\u706b\u5899\u7b56\u7565\u6846\u67b6\uff0c\u65e8\u5728\u66ff\u4ee3\u4e4b\u524d\u7684\u5404\u79cd\u9632\u706b\u5899\u5de5\u5177\u8bf8\u5982iptables/ebtables\u7b49\uff0c\u800c\u4e14\u63d0\u4f9b\u4e86\u7c7b\u4f3ctc\u7684\u5e26\u5bbd\u9650\u901f\u80fd\u529b\u3002\u800cnft\u5219\u63d0\u4f9b\u4e86nftables\u7684\u547d\u4ee4\u884c\u5165\u53e3\uff0c\u662f\u7528\u6237\u7a7a\u95f4\u7684\u7ba1\u7406\u5de5\u5177\u3002"),(0,r.kt)("h2",{id:"\u9009\u9879\u8bf4\u660e"},"\u9009\u9879\u8bf4\u660e"),(0,r.kt)("p",null,"\u6267\u884c",(0,r.kt)("inlineCode",{parentName:"p"},"nft --help"),"\u67e5\u770b\u5b8c\u6574\u5e2e\u52a9\u4fe1\u606f"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-h, --help")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u67e5\u770b\u5e2e\u52a9\u4fe1\u606f.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-v, --version")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u67e5\u770b\u7248\u672c\u53f7.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-n, --numeric")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u4ee5\u6570\u503c\u65b9\u5f0f\u5c55\u793a\u6570\u636e\uff0c\u53ef\u91cd\u590d\u4f7f\u7528\uff0c\u4e00\u4e2a-n\u8868\u793a\u4e0d\u89e3\u6790\u57df\u540d\uff0c\u7b2c\u4e8c\u6b21\u4e0d\u89e3\u6790\u7aef\u53e3\u53f7\uff0c\u7b2c\u4e09\u6b21\u4e0d\u89e3\u6790\u534f\u8bae\u548cuid/gid\u3002")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-s, --stateless")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u7701\u7565\u89c4\u5219\u548c\u6709\u72b6\u6001\u5bf9\u8c61\u7684\u72b6\u6001\u4fe1\u606f")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-N")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5c06ip\u5730\u5740\u89e3\u6790\u6210\u57df\u540d\uff0c\u4f9d\u8d56dns\u89e3\u6790\u3002")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-a, --handle")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u8f93\u51fa\u5185\u5bb9\u4e2d\u5c55\u793a\u89c4\u5219handle\u4fe1\u606f")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-I, --includepath directory")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u6dfb\u52a0include\u6587\u4ef6\u641c\u7d22\u76ee\u5f55")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-f, --file filename")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u4ece\u6587\u4ef6\u83b7\u53d6\u8f93\u5165")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-i, --interactive")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u4ece\u4ea4\u4e92\u5f0fcli\u83b7\u53d6\u8f93\u5165")),(0,r.kt)("h2",{id:"\u6587\u4ef6\u683c\u5f0f"},"\u6587\u4ef6\u683c\u5f0f"),(0,r.kt)("h3",{id:"\u8bed\u6cd5\u89c4\u5b9a"},"\u8bed\u6cd5\u89c4\u5b9a"),(0,r.kt)("p",null,"\u5355\u884c\u8fc7\u957f\u53ef\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"\\"),"\u6362\u884c\u8fde\u63a5\uff1b\n\u591a\u4e2a\u547d\u4ee4\u5199\u5230\u540c\u4e00\u884c\u53ef\u7528\u5206\u53f7",(0,r.kt)("inlineCode",{parentName:"p"},";")," \u5206\u9694\uff1b\n\u6ce8\u91ca\u4f7f\u7528\u4e95\u53f7",(0,r.kt)("inlineCode",{parentName:"p"},"#"),"\u6253\u5934\uff1b\n\u6807\u8bc6\u7b26\u7528\u5927\u5c0f\u5199\u5b57\u6bcd\u6253\u5934\uff0c\u540e\u9762\u8ddf\u6570\u5b57\u5b57\u6bcd\u4e0b\u5212\u7ebf\u6b63\u659c\u6760\u53cd\u659c\u6760\u4ee5\u53ca\u70b9\u53f7;\n\u7528\u53cc\u5f15\u53f7\u5f15\u8d77\u6765\u8868\u793a\u7eaf\u5b57\u7b26\u4e32\u3002"),(0,r.kt)("h3",{id:"\u6587\u4ef6\u5f15\u7528"},"\u6587\u4ef6\u5f15\u7528"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'include "filename"')),(0,r.kt)("p",null,"\u53ef\u7531\u5916\u90e8\u6587\u4ef6\u901a\u8fc7",(0,r.kt)("inlineCode",{parentName:"p"},"include"),"\u5bfc\u5165\u5230\u5f53\u524d\u6587\u4ef6\uff0c\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"-I/--includepath"),"\u6307\u5b9a\u5bfc\u5165\u6587\u4ef6\u6240\u5728\u76ee\u5f55\uff0c\u5982\u679cinclude\u540e\u9762\u63a5\u7684\u662f\u76ee\u5f55\u800c\u975e\u6587\u4ef6\uff0c\u5219\u6574\u4e2a\u76ee\u5f55\u7684\u6587\u4ef6\u5c06\u4ee5\u5b57\u6bcd\u987a\u5e8f\u4f9d\u6b21\u5bfc\u5165\u3002"),(0,r.kt)("h3",{id:"\u7b26\u53f7\u53d8\u91cf"},"\u7b26\u53f7\u53d8\u91cf"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"define variable = expr")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"$variable")),(0,r.kt)("p",null,"Symbolic variables can be defined using the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"define"))," statement. Variable references are expressions and can be used initialize other variables. The scope of a definition is the current block and all blocks contained within.\n\u53d8\u91cf\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"define"),"\u5b9a\u4e49\uff0c\u53d8\u91cf\u5f15\u7528\u5c5e\u4e8e\u8868\u8fbe\u5f0f\uff0c\u53ef\u4ee5\u7528\u4e8e\u521d\u59cb\u5316\u5176\u4ed6\u53d8\u91cf\uff0c\u53d8\u91cf\u7684\u751f\u6548\u8303\u56f4\u5728\u5f53\u524dblock\u4ee5\u53ca\u88ab\u5305\u542b\u7684\u6240\u6709block\u5185\u3002"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 1. \u4f7f\u7528\u7b26\u53f7\u53d8\u91cf"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"define int_if1 = eth0\ndefine int_if2 = eth1\ndefine int_ifs = { $int_if1, $int_if2 }\n\nfilter input iif $int_ifs accept\n")),(0,r.kt)("h2",{id:"\u5730\u5740\u65cf"},"\u5730\u5740\u65cf"),(0,r.kt)("p",null,"\u6839\u636e\u5904\u7406\u7684\u5305\u7684\u79cd\u7c7b\u4e0d\u540c\u53ef\u4ee5\u5c06\u5176\u5206\u4e3a\u4e0d\u540c\u7684\u5730\u5740\u65cf\u3002\u4e0d\u540c\u7684\u5730\u5740\u65cf\u5728\u5185\u6838\u4e2d\u5305\u542b\u6709\u7279\u5b9a\u9636\u6bb5\u7684\u5904\u7406\u8def\u5f84\u548chook\u70b9\uff0c\u5f53\u5bf9\u5e94hook\u7684\u89c4\u5219\u5b58\u5728\u65f6\u5219\u4f1a\u88abnftables\u5904\u7406\u3002\u5177\u4f53\u7c7b\u578b\u5982\u4e0b\uff1a"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ip")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"IPv4 \u5730\u5740\u65cf")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ip6")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"IPv6 \u5730\u5740\u65cf")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"inet")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Internet (IPv4/IPv6) \u5730\u5740\u65cf")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"arp")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"ARP \u5730\u5740\u65cf")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bridge")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Bridge \u5730\u5740\u65cf")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"netdev")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Netdev \u5730\u5740\u65cf")),(0,r.kt)("p",null,"\u6240\u6709nftables\u5bf9\u8c61\u5b58\u5728\u4e8e\u7279\u5b9a\u7684\u5730\u5740\u65cfnamespace\u4e2d\uff0c\u6362\u8a00\u4e4b\u6240\u6709identifier\u90fd\u542b\u6709\u4e00\u4e2a\u7279\u5b9a\u7684\u5730\u5740\u65cf\uff0c\u5982\u679c\u672a\u6307\u5b9a\u5219\u9ed8\u8ba4\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"ip"),"\u5730\u5740\u65cf"),(0,r.kt)("h3",{id:"ipv4ipv6inet-address-families"},"IPv4/IPv6/Inet address families"),(0,r.kt)("p",null,"IPv4/IPv6/Inet \u5730\u5740\u65cf\u7528\u4e8e\u5904\u7406 IPv4\u548cIPv6\u5305\uff0c\u5176\u5728network stack\u4e2d\u5728\u4e0d\u540c\u7684\u5305\u5904\u7406\u9636\u6bb5\u4e00\u5171\u5305\u542b\u4e865\u4e2ahook."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 1. IPv4/IPv6/Inet \u5730\u5740\u7c7bhook\u5217\u8868"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Hook\u540d\u79f0"),(0,r.kt)("th",{parentName:"tr",align:null},"\u63cf\u8ff0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"prerouting"),(0,r.kt)("td",{parentName:"tr",align:null},"\u6240\u6709\u8fdb\u5165\u5230\u7cfb\u7edf\u7684\u5305\u90fd\u4f1a\u88abprerouting hook\u8fdb\u884c\u5904\u7406. \u5b83\u5728routing\u6d41\u7a0b\u4e4b\u524d\u5c31\u88ab\u53d1\u8d77\uff0c\u7528\u4e8e\u9760\u524d\u9636\u6bb5\u7684\u5305\u8fc7\u6ee4\u6216\u8005\u66f4\u6539\u5f71\u54cdrouting\u7684\u5305\u5c5e\u6027.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"input"),(0,r.kt)("td",{parentName:"tr",align:null},"\u53d1\u5f80\u672c\u5730\u7cfb\u7edf\u7684\u5305\u5c06\u88abinput hook\u5904\u7406.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"forward"),(0,r.kt)("td",{parentName:"tr",align:null},"\u88ab\u8f6c\u53d1\u5230\u5176\u4ed6\u4e3b\u673a\u7684\u5305\u4f1a\u7ecf\u7531forward hook\u5904\u7406.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"output"),(0,r.kt)("td",{parentName:"tr",align:null},"\u7531\u672c\u5730\u8fdb\u7a0b\u53d1\u9001\u51fa\u53bb\u7684\u5305\u5c06\u88aboutput hook\u5904\u7406.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"postrouting"),(0,r.kt)("td",{parentName:"tr",align:null},"\u6240\u6709\u79bb\u5f00\u7cfb\u7edf\u7684\u5305\u90fd\u5c06\u88abpostrouting hook\u5904\u7406.")))),(0,r.kt)("h3",{id:"arp-address-family"},"ARP address family"),(0,r.kt)("p",null,"ARP\u5730\u5740\u65cf\u7528\u4e8e\u5904\u7406\u7ecf\u7531\u7cfb\u7edf\u63a5\u6536\u548c\u53d1\u9001\u7684ARP\u5305\u3002\u4e00\u822c\u5728\u96c6\u7fa4\u73af\u5883\u4e2d\u5bf9ARP\u5305\u8fdb\u884cmangle\u5904\u7406\u4ee5\u652f\u6301clustering\u3002"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 2. ARP address family hooks"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Hook"),(0,r.kt)("th",{parentName:"tr",align:null},"\u63cf\u8ff0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"input"),(0,r.kt)("td",{parentName:"tr",align:null},"\u5206\u53d1\u5230\u672c\u673a\u7684\u5305\u4f1a\u7ecf\u8fc7input hook.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"output"),(0,r.kt)("td",{parentName:"tr",align:null},"\u7531\u672c\u673a\u53d1\u51fa\u7684\u5305\u4f1a\u7ecf\u8fc7output hook.")))),(0,r.kt)("h3",{id:"bridge-address-family"},"Bridge address family"),(0,r.kt)("p",null,"bridge\u5730\u5740\u65cf\u5904\u7406\u901a\u8fc7\u6865\u63a5\u8bbe\u5907\u7684ethernet\u5305\u3002"),(0,r.kt)("h3",{id:"netdev-address-family"},"Netdev address family"),(0,r.kt)("p",null,"Netdev\u5730\u5740\u65cf\u5904\u7406\u4eceingress\u8fc7\u6765\u7684\u5305\u3002"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 3. Netdev address family hooks"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Hook"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ingress"),(0,r.kt)("td",{parentName:"tr",align:null},"\u6240\u6709\u8fdb\u5165\u7cfb\u7edf\u7684\u5305\u90fd\u5c06\u88abingress hook\u5904\u7406\u3002\u5b83\u5728\u8fdb\u5165layer 3\u4e4b\u524d\u7684\u9636\u6bb5\u5c31\u5f00\u59cb\u5904\u7406\u3002")))),(0,r.kt)("h2",{id:"tables"},"Tables"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add | delete | list | flush} table [family] {table}")),(0,r.kt)("p",null,"table\u662fchain/set/stateful object\u7684\u5bb9\u5668\uff0ctable\u7531\u5176\u5730\u5740\u65cf\u548c\u540d\u5b57\u505a\u6807\u8bc6\u3002\u5730\u5740\u65cf\u5fc5\u987b\u5c5e\u4e8eip, ip6, arp, bridge, netdev\u4e2d\u7684\u4e00\u79cd\uff0cinet\u5730\u5740\u65cf\u662f\u4e00\u4e2a\u865a\u62df\u5730\u5740\u65cf\uff0c\u540c\u6765\u521b\u5efa\u540c\u65f6\u5305\u542bIPv4\u548cIPv6\u7684table\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\u5730\u5740\u65cf\u5219\u9ed8\u8ba4\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"ip"),"\u5730\u5740\u65cf\u3002"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u6dfb\u52a0\u6307\u5b9a\u5730\u5740\u65cf\uff0c\u6307\u5b9a\u540d\u79f0\u7684table")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5220\u9664\u6307\u5b9a\u7684table")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5217\u51fa\u6307\u5b9atable\u4e2d\u7684\u6240\u6709chain\u548crule")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"flush")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u6e05\u9664\u6307\u5b9atable\u4e2d\u7684\u6240\u6709chain\u548crule")),(0,r.kt)("h2",{id:"chains"},"Chains"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add} chain [family] {table} {chain} {hook} {priority} {policy} {device}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add | create | delete | list | flush} chain [family] {table} {chain}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{rename} chain [family] {table} {chain} {newname}")),(0,r.kt)("p",null,"chain\u662frule\u7684\u5bb9\u5668\uff0c\u4ed6\u4eec\u5b58\u5728\u4e8e\u4e24\u79cd\u7c7b\u578b\uff0c\u57fa\u7840\u94fe\uff08base chain\uff09\u548c\u5e38\u89c4\u94fe\uff08regular chain\uff09\u3002base chain\u662f\u7f51\u7edc\u6808\u4e2d\u6570\u636e\u5305\u7684\u5165\u53e3\u70b9\uff0cregular chain\u5219\u53ef\u7528\u4e8ejump\u7684\u76ee\u6807\u5e76\u5bf9\u89c4\u5219\u8fdb\u884c\u66f4\u597d\u5730\u7ec4\u7ec7\u3002"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5728\u6307\u5b9atable\u4e2d\u6dfb\u52a0\u65b0\u7684\u94fe\uff0c\u5f53hook\u548c\u6743\u91cd\u503c\u88ab\u6307\u5b9a\u65f6\uff0c\u6dfb\u52a0\u7684chain\u4e3abase chain\uff0c\u5c06\u5728\u7f51\u7edc\u6808\u4e2dhook\u76f8\u5173\u8054\u3002")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"create")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u4e0e",(0,r.kt)("inlineCode",{parentName:"p"},"add"),"\u547d\u4ee4\u7c7b\u4f3c\uff0c\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5f53\u521b\u5efa\u7684chain\u5b58\u5728\u65f6\u4f1a\u8fd4\u56de\u9519\u8bef\u3002")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5220\u9664\u6307\u5b9a\u7684chain\uff0c\u88ab\u5220\u9664\u7684chain\u4e0d\u80fd\u6709\u89c4\u5219\u4e14\u4e0d\u80fd\u662f\u8df3\u8f6c\u76ee\u6807chain\u3002")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rename")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u91cd\u547d\u540dchain")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5217\u51fa\u6307\u5b9achain\u4e2d\u7684\u6240\u6709rule")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"flush")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u6e05\u9664\u6307\u5b9achain\u4e2d\u6240\u6709rule")),(0,r.kt)("h2",{id:"rules"},"Rules"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[add | insert] rule [family] {table} {chain} [position position] {statement...}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{delete} rule [family] {table} {chain} {handle handle}")),(0,r.kt)("p",null,"Rules are constructed from two kinds of components according to a set of grammatical rules: expressions and statements."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Add a new rule described by the list of statements. The rule is appended to the given chain unless a position is specified, in which case the rule is appended to the rule given by the position.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"insert")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Similar to the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"add"))," command, but the rule is prepended to the beginning of the chain or before the rule at the given position.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Delete the specified rule.")),(0,r.kt)("h2",{id:"sets"},"Sets"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add} set family] {table} {set}{ {type} [flags] [timeout] [gc-interval] [elements] [size] [policy]}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{delete | list | flush} set [family] {table} {set}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add | delete} element [family] {table} {set}{ {elements}}")),(0,r.kt)("p",null,"Sets are elements containers of an user-defined data type, they are uniquely identified by an user-defined name and attached to tables.\nsets \u662f\u7528\u6237\u5b9a\u4e49\u7684\u6570\u636e\u7c7b\u578b\u7684\u5bb9\u5668\uff0c\u5177\u6709\u7528\u6237\u5b9a\u4e49\u7684\u552f\u4e00\u6807\u8bc6\uff0c\u88ab\u5e94\u7528\u5230table\u4e0a\u3002"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5728\u6307\u5b9a\u7684table\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684set")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5220\u9664\u6307\u5b9aset")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u67e5\u770bset\u5185\u7684\u5143\u7d20")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"flush")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u6e05\u7a7a\u6574\u4e2aset")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add element")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u5f80set\u4e2d\u6dfb\u52a0\u5143\u7d20\uff0c\u591a\u4e2a\u4f7f\u7528\u9017\u53f7\u5206\u9694")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete element")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"\u4eceset\u4e2d\u5220\u9664\u5143\u7d20\uff0c\u591a\u4e2a\u4f7f\u7528\u9017\u53f7\u5206\u9694")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 4. Set \u53c2\u6570"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\u5173\u952e\u5b57"),(0,r.kt)("th",{parentName:"tr",align:null},"\u63cf\u8ff0"),(0,r.kt)("th",{parentName:"tr",align:null},"\u7c7b\u578b"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"\u5143\u7d20\u7684\u6570\u636e\u7c7b\u578b"),(0,r.kt)("td",{parentName:"tr",align:null},"string: ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flags"),(0,r.kt)("td",{parentName:"tr",align:null},"set flags"),(0,r.kt)("td",{parentName:"tr",align:null},"string: constant, interval, timeout")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"timeout"),(0,r.kt)("td",{parentName:"tr",align:null},"\u5143\u7d20\u5728set\u4e2d\u7684\u5b58\u6d3b\u65f6\u95f4"),(0,r.kt)("td",{parentName:"tr",align:null},"string, \u5e26\u5355\u4f4d\u7684\u5c0f\u6570. \u5355\u4f4d: d, h, m, s")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gc-interval"),(0,r.kt)("td",{parentName:"tr",align:null},"\u5783\u573e\u56de\u6536\u95f4\u9694, \u4ec5\u5f53timeout\u6216flag timeout\u8bbe\u7f6e\u65f6\u751f\u6548"),(0,r.kt)("td",{parentName:"tr",align:null},"string, decimal followed by unit. Units are: d, h, m, s")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elements"),(0,r.kt)("td",{parentName:"tr",align:null},"set\u4e2d\u5305\u542b\u7684\u5143\u7d20"),(0,r.kt)("td",{parentName:"tr",align:null},"set data type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size"),(0,r.kt)("td",{parentName:"tr",align:null},"set\u53ef\u5b58\u653e\u7684\u6700\u5927\u5143\u7d20\u4e2a\u6570"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"policy"),(0,r.kt)("td",{parentName:"tr",align:null},"set policy"),(0,r.kt)("td",{parentName:"tr",align:null},"string: performance ","[default]",", memory")))),(0,r.kt)("h2",{id:"maps"},"Maps"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add} map [family] {table} {map}{ {type} [flags] [elements] [size] [policy]}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{delete | list | flush} map [family] {table} {map}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add | delete} element [family] {table} {map}{ {elements}}")),(0,r.kt)("p",null,"Maps store data based on some specific key used as input, they are uniquely identified by an user-defined name and attached to tables."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Add a new map in the specified table.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Delete the specified map.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Display the elements in the specified map.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"flush")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Remove all elements from the specified map.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add element")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Comma-separated list of elements to add into the specified map.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete element")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Comma-separated list of element keys to delete from the specified map.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 5. Map specifications"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"data type of map elements"),(0,r.kt)("td",{parentName:"tr",align:null},"string ':' string: ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark, counter, quota. Counter and quota can't be used as keys")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flags"),(0,r.kt)("td",{parentName:"tr",align:null},"map flags"),(0,r.kt)("td",{parentName:"tr",align:null},"string: constant, interval")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elements"),(0,r.kt)("td",{parentName:"tr",align:null},"elements contained by the map"),(0,r.kt)("td",{parentName:"tr",align:null},"map data type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size"),(0,r.kt)("td",{parentName:"tr",align:null},"maximun number of elements in the map"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"policy"),(0,r.kt)("td",{parentName:"tr",align:null},"map policy"),(0,r.kt)("td",{parentName:"tr",align:null},"string: performance ","[default]",", memory")))),(0,r.kt)("h2",{id:"stateful-objects"},"Stateful objects"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{add | delete | list | reset} type [family] {table} {object}")),(0,r.kt)("p",null,'Stateful objects are attached to tables and are identified by an unique name. They group stateful information from rules, to reference them in rules the keywords "type name" are used e.g. "counter name".'),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Add a new stateful object in the specified table.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Delete the specified object.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Display stateful information the object holds.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"reset")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"List-and-reset stateful object.")),(0,r.kt)("h3",{id:"ct"},"Ct"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ct"))," {helper} {type} {type} {protocol} {protocol} ","[l3proto][family]"),(0,r.kt)("p",null,'Ct helper is used to define connection tracking helpers that can then be used in combination with the "ct helper set" statement. type and protocol are mandatory, l3proto is derived from the table family by default, i.e. in the inet table the kernel will try to load both the ipv4 and ipv6 helper backends, if they are supported by the kernel.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 6. conntrack helper specifications"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"name of helper type"),(0,r.kt)("td",{parentName:"tr",align:null},'quoted string (e.g. "ftp")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"layer 4 protocol of the helper"),(0,r.kt)("td",{parentName:"tr",align:null},"string (e.g. tcp)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"l3proto"),(0,r.kt)("td",{parentName:"tr",align:null},"layer 3 protocol of the helper"),(0,r.kt)("td",{parentName:"tr",align:null},"address family (e.g. ip)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 2. defining and assigning ftp helper"))),(0,r.kt)("p",null,"Unlike iptables, helper assignment needs to be performed after the conntrack lookup has completed, for example with the default 0 hook priority."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'table inet myhelpers {\n  ct helper ftp-standard {\n     type "ftp" protocol tcp\n  }\n  chain prerouting {\n      type filter hook prerouting priority 0;\n      tcp dport 21 ct helper set "ftp-standard"\n  }\n}\n\n')),(0,r.kt)("h3",{id:"counter"},"Counter"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"counter"))," ","[packets bytes]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 7. Counter specifications"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"packets"),(0,r.kt)("td",{parentName:"tr",align:null},"initial count of packets"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"initial count of bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (64 bit)")))),(0,r.kt)("h3",{id:"quota"},"Quota"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"quota"))," ","[over | until][used]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 8. Quota specifications"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"quota"),(0,r.kt)("td",{parentName:"tr",align:null},"quota limit, used as the quota name"),(0,r.kt)("td",{parentName:"tr",align:null},'Two arguments, unsigned interger (64 bit) and string: bytes, kbytes, mbytes. "over" and "until" go before these arguments')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"used"),(0,r.kt)("td",{parentName:"tr",align:null},"initial value of used quota"),(0,r.kt)("td",{parentName:"tr",align:null},"Two arguments, unsigned interger (64 bit) and string: bytes, kbytes, mbytes")))),(0,r.kt)("h2",{id:"expressions"},"Expressions"),(0,r.kt)("p",null,"Expressions represent values, either constants like network addresses, port numbers etc. or data gathered from the packet during ruleset evaluation. Expressions can be combined using binary, logical, relational and other types of expressions to form complex or relational (match) expressions. They are also used as arguments to certain types of operations, like NAT, packet marking etc."),(0,r.kt)("p",null,"Each expression has a data type, which determines the size, parsing and representation of symbolic values and type compatibility with other expressions."),(0,r.kt)("h3",{id:"describe-command"},"describe command"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"describe {expression}")),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"describe"))," command shows information about the type of an expression and its data type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 3. The ",(0,r.kt)("inlineCode",{parentName:"em"},"describe")," command"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ nft describe tcp flags\npayload expression, datatype tcp_flag (TCP flag) (basetype bitmask, integer), 8 bits\n\npre-defined symbolic constants:\nfin                               0x01\nsyn                               0x02\nrst                               0x04\npsh                               0x08\nack                               0x10\nurg                               0x20\necn                               0x40\ncwr                               0x80\n\n")),(0,r.kt)("h2",{id:"data-types"},"Data types"),(0,r.kt)("p",null,"Data types determine the size, parsing and representation of symbolic values and type compatibility of expressions. A number of global data types exist, in addition some expression types define further data types specific to the expression type. Most data types have a fixed size, some however may have a dynamic size, f.i. the string type."),(0,r.kt)("p",null,"Types may be derived from lower order types, f.i. the IPv4 address type is derived from the integer type, meaning an IPv4 address can also be specified as an integer value."),(0,r.kt)("p",null,"In certain contexts (set and map definitions) it is necessary to explicitly specify a data type. Each type has a name which is used for this."),(0,r.kt)("h3",{id:"integer-type"},"Integer type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 9."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Integer"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"variable"),(0,r.kt)("td",{parentName:"tr",align:null},"-")))),(0,r.kt)("p",null,"The integer type is used for numeric values. It may be specified as decimal, hexadecimal or octal number. The integer type doesn't have a fixed size, its size is determined by the expression for which it is used."),(0,r.kt)("h3",{id:"bitmask-type"},"Bitmask type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 10."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitmask"),(0,r.kt)("td",{parentName:"tr",align:null},"bitmask"),(0,r.kt)("td",{parentName:"tr",align:null},"variable"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The bitmask type (",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"bitmask")),") is used for bitmasks."),(0,r.kt)("h3",{id:"string-type"},"String type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 11."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"String"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"variable"),(0,r.kt)("td",{parentName:"tr",align:null},"-")))),(0,r.kt)("p",null,'The string type is used to for character strings. A string begins with an alphabetic character (a-zA-Z) followed by zero or more alphanumeric characters or the characters /, -, _ and .. In addition anything enclosed in double quotes (") is recognized as a string.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 4. String specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'\n# Interface name\nfilter input iifname eth0\n\n# Weird interface name\nfilter input iifname "(eth0)"\n\n')),(0,r.kt)("h3",{id:"link-layer-address-type"},"Link layer address type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 12."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Link layer address"),(0,r.kt)("td",{parentName:"tr",align:null},"lladdr"),(0,r.kt)("td",{parentName:"tr",align:null},"variable"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The link layer address type is used for link layer addresses. Link layer addresses are specified as a variable amount of groups of two hexadecimal digits separated using colons (:)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 5. Link layer address specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# Ethernet destination MAC address\nfilter input ether daddr 20:c9:d0:43:12:d9\n\n")),(0,r.kt)("h3",{id:"ipv4-address-type"},"IPv4 address type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 13."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IPv4 address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr"),(0,r.kt)("td",{parentName:"tr",align:null},"32 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The IPv4 address type is used for IPv4 addresses. Addresses are specified in either dotted decimal, dotted hexadecimal, dotted octal, decimal, hexadecimal, octal notation or as a host name. A host name will be resolved using the standard system resolver."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 6. IPv4 address specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# dotted decimal notation\nfilter output ip daddr 127.0.0.1\n\n# host name\nfilter output ip daddr localhost\n\n")),(0,r.kt)("h3",{id:"ipv6-address-type"},"IPv6 address type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 14."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IPv6 address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv6_addr"),(0,r.kt)("td",{parentName:"tr",align:null},"128 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The IPv6 address type is used for IPv6 addresses. FIXME"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 7. IPv6 address specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# abbreviated loopback address\nfilter output ip6 daddr ::1\n\n")),(0,r.kt)("h3",{id:"boolean-type"},"Boolean type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 15."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The boolean type is a syntactical helper type in user space. It's use is in the right-hand side of a (typically implicit) relational expression to change the expression on the left-hand side into a boolean check (usually for existence)."),(0,r.kt)("p",null,"The following keywords will automatically resolve into a boolean type with given value:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 16."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"exists"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"missing"),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 8. Boolean specification"))),(0,r.kt)("p",null,"The following expressions support a boolean comparison:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 17."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Expression"),(0,r.kt)("th",{parentName:"tr",align:null},"Behaviour"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fib"),(0,r.kt)("td",{parentName:"tr",align:null},"Check route existence.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"exthdr"),(0,r.kt)("td",{parentName:"tr",align:null},"Check IPv6 extension header existence.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tcp option"),(0,r.kt)("td",{parentName:"tr",align:null},"Check TCP option header existence.")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# match if route exists\nfilter input fib daddr . iif oif exists\n\n# match only non-fragmented packets in IPv6 traffic\nfilter input exthdr frag missing\n\n# match if TCP timestamp option is present\nfilter input tcp option timestamp exists\n\n")),(0,r.kt)("h3",{id:"icmp-type-type"},"ICMP Type type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 18."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ICMP Type"),(0,r.kt)("td",{parentName:"tr",align:null},"icmp_type"),(0,r.kt)("td",{parentName:"tr",align:null},"8 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The ICMP Type type is used to conveniently specify the ICMP header's type field."),(0,r.kt)("p",null,"The following keywords may be used when specifying the ICMP type:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 19."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"echo-reply"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destination-unreachable"),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"source-quench"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"redirect"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"echo-request"),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"router-advertisement"),(0,r.kt)("td",{parentName:"tr",align:null},"9")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"router-solicitation"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"time-exceeded"),(0,r.kt)("td",{parentName:"tr",align:null},"11")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"parameter-problem"),(0,r.kt)("td",{parentName:"tr",align:null},"12")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"timestamp-request"),(0,r.kt)("td",{parentName:"tr",align:null},"13")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"timestamp-reply"),(0,r.kt)("td",{parentName:"tr",align:null},"14")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"info-request"),(0,r.kt)("td",{parentName:"tr",align:null},"15")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"info-reply"),(0,r.kt)("td",{parentName:"tr",align:null},"16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"address-mask-request"),(0,r.kt)("td",{parentName:"tr",align:null},"17")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"address-mask-reply"),(0,r.kt)("td",{parentName:"tr",align:null},"18")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 9. ICMP Type specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# match ping packets\nfilter output icmp type { echo-request, echo-reply }\n\n")),(0,r.kt)("h3",{id:"icmpv6-type-type"},"ICMPv6 Type type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 20."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Base type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ICMPv6 Type"),(0,r.kt)("td",{parentName:"tr",align:null},"icmpv6_type"),(0,r.kt)("td",{parentName:"tr",align:null},"8 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer")))),(0,r.kt)("p",null,"The ICMPv6 Type type is used to conveniently specify the ICMPv6 header's type field."),(0,r.kt)("p",null,"The following keywords may be used when specifying the ICMPv6 type:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 21."))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destination-unreachable"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"packet-too-big"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"time-exceeded"),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"parameter-problem"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"echo-request"),(0,r.kt)("td",{parentName:"tr",align:null},"128")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"echo-reply"),(0,r.kt)("td",{parentName:"tr",align:null},"129")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mld-listener-query"),(0,r.kt)("td",{parentName:"tr",align:null},"130")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mld-listener-report"),(0,r.kt)("td",{parentName:"tr",align:null},"131")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mld-listener-done"),(0,r.kt)("td",{parentName:"tr",align:null},"132")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mld-listener-reduction"),(0,r.kt)("td",{parentName:"tr",align:null},"132")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nd-router-solicit"),(0,r.kt)("td",{parentName:"tr",align:null},"133")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nd-router-advert"),(0,r.kt)("td",{parentName:"tr",align:null},"134")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nd-neighbor-solicit"),(0,r.kt)("td",{parentName:"tr",align:null},"135")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nd-neighbor-advert"),(0,r.kt)("td",{parentName:"tr",align:null},"136")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nd-redirect"),(0,r.kt)("td",{parentName:"tr",align:null},"137")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"router-renumbering"),(0,r.kt)("td",{parentName:"tr",align:null},"138")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ind-neighbor-solicit"),(0,r.kt)("td",{parentName:"tr",align:null},"141")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ind-neighbor-advert"),(0,r.kt)("td",{parentName:"tr",align:null},"142")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mld2-listener-report"),(0,r.kt)("td",{parentName:"tr",align:null},"143")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 10. ICMPv6 Type specification"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# match ICMPv6 ping packets\nfilter output icmpv6 type { echo-request, echo-reply }\n\n")),(0,r.kt)("h2",{id:"primary-expressions"},"Primary expressions"),(0,r.kt)("p",null,"The lowest order expression is a primary expression, representing either a constant or a single datum from a packet's payload, meta data or a stateful module."),(0,r.kt)("h3",{id:"meta-expressions"},"Meta expressions"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"meta {length | nfproto | l4proto | protocol | priority}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[meta] {mark | iif | iifname | iiftype | oif | oifname | oiftype}"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"[meta] {skuid | skgid | nftrace | rtclassid | ibriport | obriport | pkttype | cpu | iifgroup | oifgroup | cgroup | random}")),(0,r.kt)("p",null,"A meta expression refers to meta data associated with a packet."),(0,r.kt)("p",null,"There are two types of meta expressions: unqualified and qualified meta expressions. Qualified meta expressions require the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"meta"))," keyword before the meta key, unqualified meta expressions can be specified by using the meta key directly or as qualified meta expressions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 22. Meta expression types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"length"),(0,r.kt)("td",{parentName:"tr",align:null},"Length of the packet in bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"Ethertype protocol value"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"priority"),(0,r.kt)("td",{parentName:"tr",align:null},"TC packet priority"),(0,r.kt)("td",{parentName:"tr",align:null},"tc_handle")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mark"),(0,r.kt)("td",{parentName:"tr",align:null},"Packet mark"),(0,r.kt)("td",{parentName:"tr",align:null},"mark")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iif"),(0,r.kt)("td",{parentName:"tr",align:null},"Input interface index"),(0,r.kt)("td",{parentName:"tr",align:null},"iface_index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iifname"),(0,r.kt)("td",{parentName:"tr",align:null},"Input interface name"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iiftype"),(0,r.kt)("td",{parentName:"tr",align:null},"Input interface type"),(0,r.kt)("td",{parentName:"tr",align:null},"iface_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oif"),(0,r.kt)("td",{parentName:"tr",align:null},"Output interface index"),(0,r.kt)("td",{parentName:"tr",align:null},"iface_index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oifname"),(0,r.kt)("td",{parentName:"tr",align:null},"Output interface name"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oiftype"),(0,r.kt)("td",{parentName:"tr",align:null},"Output interface hardware type"),(0,r.kt)("td",{parentName:"tr",align:null},"iface_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skuid"),(0,r.kt)("td",{parentName:"tr",align:null},"UID associated with originating socket"),(0,r.kt)("td",{parentName:"tr",align:null},"uid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skgid"),(0,r.kt)("td",{parentName:"tr",align:null},"GID associated with originating socket"),(0,r.kt)("td",{parentName:"tr",align:null},"gid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rtclassid"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing realm"),(0,r.kt)("td",{parentName:"tr",align:null},"realm")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ibriport"),(0,r.kt)("td",{parentName:"tr",align:null},"Input bridge interface name"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"obriport"),(0,r.kt)("td",{parentName:"tr",align:null},"Output bridge interface name"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pkttype"),(0,r.kt)("td",{parentName:"tr",align:null},"packet type"),(0,r.kt)("td",{parentName:"tr",align:null},"pkt_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cpu"),(0,r.kt)("td",{parentName:"tr",align:null},"cpu number processing the packet"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bits)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iifgroup"),(0,r.kt)("td",{parentName:"tr",align:null},"incoming device group"),(0,r.kt)("td",{parentName:"tr",align:null},"devgroup")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oifgroup"),(0,r.kt)("td",{parentName:"tr",align:null},"outgoing device group"),(0,r.kt)("td",{parentName:"tr",align:null},"devgroup")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cgroup"),(0,r.kt)("td",{parentName:"tr",align:null},"control group id"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bits)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"random"),(0,r.kt)("td",{parentName:"tr",align:null},"pseudo-random number"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bits)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 23. Meta expression specific types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iface_index"),(0,r.kt)("td",{parentName:"tr",align:null},"Interface index (32 bit number). Can be specified numerically or as name of an existing interface.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ifname"),(0,r.kt)("td",{parentName:"tr",align:null},"Interface name (16 byte string). Does not have to exist.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iface_type"),(0,r.kt)("td",{parentName:"tr",align:null},"Interface type (16 bit number).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uid"),(0,r.kt)("td",{parentName:"tr",align:null},"User ID (32 bit number). Can be specified numerically or as user name.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gid"),(0,r.kt)("td",{parentName:"tr",align:null},"Group ID (32 bit number). Can be specified numerically or as group name.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"realm"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing Realm (32 bit number). Can be specified numerically or as symbolic name defined in /etc/iproute2/rt_realms.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"devgroup_type"),(0,r.kt)("td",{parentName:"tr",align:null},"Device group (32 bit number). Can be specified numerically or as symbolic name defined in /etc/iproute2/group.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pkt_type"),(0,r.kt)("td",{parentName:"tr",align:null},"Packet type: Unicast (addressed to local host), Broadcast (to all), Multicast (to group).")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 11. Using meta expressions"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# qualified meta expression\nfilter output meta oif eth0\n\n# unqualified meta expression\nfilter output oif eth0\n\n")),(0,r.kt)("h3",{id:"fib-expressions"},"fib expressions"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"fib"))," {saddr | daddr ","[mark | iif | oif]","} {oif | oifname | type}"),(0,r.kt)("p",null,"A fib expression queries the fib (forwarding information base) to obtain information such as the output interface index a particular address would use. The input is a tuple of elements that is used as input to the fib lookup functions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 24. fib expression specific types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oif"),(0,r.kt)("td",{parentName:"tr",align:null},"Output interface index"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oifname"),(0,r.kt)("td",{parentName:"tr",align:null},"Output interface name"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"Address type"),(0,r.kt)("td",{parentName:"tr",align:null},"fib_addrtype")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 12. Using fib expressions"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# drop packets without a reverse path\nfilter prerouting fib saddr . iif oif missing drop\n\n# drop packets to address not configured on ininterface\nfilter prerouting fib daddr . iif type != { local, broadcast, multicast } drop\n\n# perform lookup in a specific 'blackhole' table (0xdead, needs ip appropriate ip rule)\nfilter prerouting meta mark set 0xdead fib daddr . mark type vmap { blackhole : drop, prohibit : jump prohibited, unreachable : drop }\n\n")),(0,r.kt)("h3",{id:"routing-expressions"},"Routing expressions"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"rt"))," {classid | nexthop}"),(0,r.kt)("p",null,"A routing expression refers to routing data associated with a packet."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 25. Routing expression types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"classid"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing realm"),(0,r.kt)("td",{parentName:"tr",align:null},"realm")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nexthop"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing nexthop"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr/ipv6_addr")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 26. Routing expression specific types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"realm"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing Realm (32 bit number). Can be specified numerically or as symbolic name defined in /etc/iproute2/rt_realms.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 13. Using routing expressions"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n# IP family independent rt expression\nfilter output rt classid 10\n\n# IP family dependent rt expressions\nip filter output rt nexthop 192.168.0.1\nip6 filter output rt nexthop fd00::1\ninet filter meta nfproto ipv4 output rt nexthop 192.168.0.1\ninet filter meta nfproto ipv6 output rt nexthop fd00::1\n\n")),(0,r.kt)("h2",{id:"payload-expressions"},"Payload expressions"),(0,r.kt)("p",null,"Payload expressions refer to data from the packet's payload."),(0,r.kt)("h3",{id:"ethernet-header-expression"},"Ethernet header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ether"))," ","[",(0,r.kt)("em",{parentName:"p"},"ethernet header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 27. Ethernet header expression types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"daddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination MAC address"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"saddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Source MAC address"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"EtherType"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_type")))),(0,r.kt)("h3",{id:"vlan-header-expression"},"VLAN header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"vlan"))," ","[",(0,r.kt)("em",{parentName:"p"},"VLAN header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 28. VLAN header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"VLAN ID (VID)"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (12 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cfi"),(0,r.kt)("td",{parentName:"tr",align:null},"Canonical Format Indicator"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (1 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pcp"),(0,r.kt)("td",{parentName:"tr",align:null},"Priority code point"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (3 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"EtherType"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_type")))),(0,r.kt)("h3",{id:"arp-header-expression"},"ARP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"arp"))," ","[",(0,r.kt)("em",{parentName:"p"},"ARP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 29. ARP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"htype"),(0,r.kt)("td",{parentName:"tr",align:null},"ARP hardware type"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptype"),(0,r.kt)("td",{parentName:"tr",align:null},"EtherType"),(0,r.kt)("td",{parentName:"tr",align:null},"ether_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hlen"),(0,r.kt)("td",{parentName:"tr",align:null},"Hardware address len"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"plen"),(0,r.kt)("td",{parentName:"tr",align:null},"Protocol address len"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"operation"),(0,r.kt)("td",{parentName:"tr",align:null},"Operation"),(0,r.kt)("td",{parentName:"tr",align:null},"arp_op")))),(0,r.kt)("h3",{id:"ipv4-header-expression"},"IPv4 header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ip"))," ","[",(0,r.kt)("em",{parentName:"p"},"IPv4 header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 30. IPv4 header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"version"),(0,r.kt)("td",{parentName:"tr",align:null},"IP header version (4)"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (4 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hdrlength"),(0,r.kt)("td",{parentName:"tr",align:null},"IP header length including options"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (4 bit) FIXME scaling")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dscp"),(0,r.kt)("td",{parentName:"tr",align:null},"Differentiated Services Code Point"),(0,r.kt)("td",{parentName:"tr",align:null},"dscp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ecn"),(0,r.kt)("td",{parentName:"tr",align:null},"Explicit Congestion Notification"),(0,r.kt)("td",{parentName:"tr",align:null},"ecn")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"length"),(0,r.kt)("td",{parentName:"tr",align:null},"Total packet length"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"IP ID"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"frag-off"),(0,r.kt)("td",{parentName:"tr",align:null},"Fragment offset"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ttl"),(0,r.kt)("td",{parentName:"tr",align:null},"Time to live"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"Upper layer protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"IP header checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"saddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Source address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"daddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr")))),(0,r.kt)("h3",{id:"icmp-header-expression"},"ICMP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"icmp"))," ","[",(0,r.kt)("em",{parentName:"p"},"ICMP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 31. ICMP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMP type field"),(0,r.kt)("td",{parentName:"tr",align:null},"icmp_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"code"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMP code field"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMP checksum field"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"ID of echo request/response"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"sequence number of echo request/response"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gateway"),(0,r.kt)("td",{parentName:"tr",align:null},"gateway of redirects"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mtu"),(0,r.kt)("td",{parentName:"tr",align:null},"MTU of path MTU discovery"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"ipv6-header-expression"},"IPv6 header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ip6"))," ","[",(0,r.kt)("em",{parentName:"p"},"IPv6 header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 32. IPv6 header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"version"),(0,r.kt)("td",{parentName:"tr",align:null},"IP header version (6)"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (4 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dscp"),(0,r.kt)("td",{parentName:"tr",align:null},"Differentiated Services Code Point"),(0,r.kt)("td",{parentName:"tr",align:null},"dscp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ecn"),(0,r.kt)("td",{parentName:"tr",align:null},"Explicit Congestion Notification"),(0,r.kt)("td",{parentName:"tr",align:null},"ecn")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flowlabel"),(0,r.kt)("td",{parentName:"tr",align:null},"Flow label"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (20 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"length"),(0,r.kt)("td",{parentName:"tr",align:null},"Payload length"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nexthdr"),(0,r.kt)("td",{parentName:"tr",align:null},"Nexthdr protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoplimit"),(0,r.kt)("td",{parentName:"tr",align:null},"Hop limit"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"saddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Source address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv6_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"daddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination address"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv6_addr")))),(0,r.kt)("h3",{id:"icmpv6-header-expression"},"ICMPv6 header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"icmpv6"))," ","[",(0,r.kt)("em",{parentName:"p"},"ICMPv6 header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 33. ICMPv6 header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMPv6 type field"),(0,r.kt)("td",{parentName:"tr",align:null},"icmpv6_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"code"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMPv6 code field"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMPv6 checksum field"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"parameter-problem"),(0,r.kt)("td",{parentName:"tr",align:null},"pointer to problem"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"packet-too-big"),(0,r.kt)("td",{parentName:"tr",align:null},"oversized MTU"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"ID of echo request/response"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"sequence number of echo request/response"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max-delay"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum response delay of MLD queries"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"tcp-header-expression"},"TCP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"tcp"))," ","[",(0,r.kt)("em",{parentName:"p"},"TCP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 34. TCP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sport"),(0,r.kt)("td",{parentName:"tr",align:null},"Source port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dport"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"Sequence number"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ackseq"),(0,r.kt)("td",{parentName:"tr",align:null},"Acknowledgement number"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"doff"),(0,r.kt)("td",{parentName:"tr",align:null},"Data offset"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (4 bit) FIXME scaling")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reserved"),(0,r.kt)("td",{parentName:"tr",align:null},"Reserved area"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (4 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flags"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP flags"),(0,r.kt)("td",{parentName:"tr",align:null},"tcp_flag")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"window"),(0,r.kt)("td",{parentName:"tr",align:null},"Window"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"Checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"urgptr"),(0,r.kt)("td",{parentName:"tr",align:null},"Urgent pointer"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"udp-header-expression"},"UDP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"udp"))," ","[",(0,r.kt)("em",{parentName:"p"},"UDP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 35. UDP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sport"),(0,r.kt)("td",{parentName:"tr",align:null},"Source port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dport"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"length"),(0,r.kt)("td",{parentName:"tr",align:null},"Total packet length"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"Checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"udp-lite-header-expression"},"UDP-Lite header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"udplite"))," ","[",(0,r.kt)("em",{parentName:"p"},"UDP-Lite header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 36. UDP-Lite header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sport"),(0,r.kt)("td",{parentName:"tr",align:null},"Source port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dport"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"Checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"sctp-header-expression"},"SCTP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"sctp"))," ","[",(0,r.kt)("em",{parentName:"p"},"SCTP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 37. SCTP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sport"),(0,r.kt)("td",{parentName:"tr",align:null},"Source port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dport"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"vtag"),(0,r.kt)("td",{parentName:"tr",align:null},"Verfication Tag"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"Checksum"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")))),(0,r.kt)("h3",{id:"dccp-header-expression"},"DCCP header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"dccp"))," ","[",(0,r.kt)("em",{parentName:"p"},"DCCP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 38. DCCP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sport"),(0,r.kt)("td",{parentName:"tr",align:null},"Source port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dport"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination port"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_service")))),(0,r.kt)("h3",{id:"authentication-header-expression"},"Authentication header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ah"))," ","[",(0,r.kt)("em",{parentName:"p"},"AH header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 39. AH header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nexthdr"),(0,r.kt)("td",{parentName:"tr",align:null},"Next header protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hdrlength"),(0,r.kt)("td",{parentName:"tr",align:null},"AH Header length"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (8 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reserved"),(0,r.kt)("td",{parentName:"tr",align:null},"Reserved area"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"spi"),(0,r.kt)("td",{parentName:"tr",align:null},"Security Parameter Index"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"Sequence number"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")))),(0,r.kt)("h3",{id:"encrypted-security-payload-header-expression"},"Encrypted security payload header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"esp"))," ","[",(0,r.kt)("em",{parentName:"p"},"ESP header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 40. ESP header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"spi"),(0,r.kt)("td",{parentName:"tr",align:null},"Security Parameter Index"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"Sequence number"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (32 bit)")))),(0,r.kt)("h3",{id:"ipcomp-header-expression"},"IPcomp header expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"comp"))," ","[",(0,r.kt)("em",{parentName:"p"},"IPComp header field"),"]"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 41. IPComp header expression"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nexthdr"),(0,r.kt)("td",{parentName:"tr",align:null},"Next header protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flags"),(0,r.kt)("td",{parentName:"tr",align:null},"Flags"),(0,r.kt)("td",{parentName:"tr",align:null},"bitmask")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cpi"),(0,r.kt)("td",{parentName:"tr",align:null},"Compression Parameter Index"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h3",{id:"extension-header-expressions"},"Extension header expressions"),(0,r.kt)("p",null,"Extension header expressions refer to data from variable-sized protocol headers, such as IPv6 extension headers and TCPs options."),(0,r.kt)("p",null,"nftables currently supports matching (finding) a given ipv6 extension header or TCP option."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"hbh {nexthdr | hdrlength}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"frag {nexthdr | frag-off | more-fragments | id}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rt {nexthdr | hdrlength | type | seg-left}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dst {nexthdr | hdrlength}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mh {nexthdr | hdrlength | checksum | type}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tcp option {eol | noop | maxseg | window | sack-permitted | sack | sack0 | sack1 | sack2 | sack3 | timestamp} [_tcp_option_field_]")),(0,r.kt)("p",null,"The following syntaxes are valid only in a relational expression with boolean type on right-hand side for checking header existence only:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"exthdr {hbh | frag | rt | dst | mh}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tcp option {eol | noop | maxseg | window | sack-permitted | sack | sack0 | sack1 | sack2 | sack3 | timestamp}")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 42. IPv6 extension headers"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hbh"),(0,r.kt)("td",{parentName:"tr",align:null},"Hop by Hop")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rt"),(0,r.kt)("td",{parentName:"tr",align:null},"Routing Header")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"frag"),(0,r.kt)("td",{parentName:"tr",align:null},"Fragmentation header")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dst"),(0,r.kt)("td",{parentName:"tr",align:null},"dst options")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mh"),(0,r.kt)("td",{parentName:"tr",align:null},"Mobility Header")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 43. TCP Options"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"TCP option fields"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eol"),(0,r.kt)("td",{parentName:"tr",align:null},"End of option list"),(0,r.kt)("td",{parentName:"tr",align:null},"kind")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"noop"),(0,r.kt)("td",{parentName:"tr",align:null},"1 Byte TCP No-op options"),(0,r.kt)("td",{parentName:"tr",align:null},"kind")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"maxseg"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Maximum Segment Size"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, size")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"window"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Window Scaling"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, count")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack-permitted"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP SACK permitted"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Selective Acknowledgement (alias of block 0)"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, left, right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack0"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Selective Acknowledgement (block 0)"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, left, right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack1"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Selective Acknowledgement (block 1)"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, left, right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack2"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Selective Acknowledgement (block 2)"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, left, right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sack3"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Selective Acknowledgement (block 3)"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, left, right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"TCP Timestamps"),(0,r.kt)("td",{parentName:"tr",align:null},"kind, length, tsval, tsecr")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 14. finding TCP options"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"filter input tcp option sack-permitted kind 1 counter\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 15. matching IPv6 exthdr"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ip6 filter input frag more-fragments 1 counter\n")),(0,r.kt)("h3",{id:"conntrack-expressions"},"Conntrack expressions"),(0,r.kt)("p",null,"Conntrack expressions refer to meta data of the connection tracking entry associated with a packet."),(0,r.kt)("p",null,"There are three types of conntrack expressions. Some conntrack expressions require the flow direction before the conntrack key, others must be used directly because they are direction agnostic. The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"packets")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"bytes"))," and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"avgpkt"))," keywords can be used with or without a direction. If the direction is omitted, the sum of the original and the reply direction is returned. The same is true for the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"zone")),", if a direction is given, the zone is only matched if the zone id is tied to the given direction."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ct {state | direction | status | mark | expiration | helper | label | l3proto | protocol | bytes | packets | avgpkt | zone}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ct {original | reply} {l3proto | protocol | saddr | daddr | proto-src | proto-dst | bytes | packets | avgpkt | zone}")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 44. Conntrack expressions"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"state"),(0,r.kt)("td",{parentName:"tr",align:null},"State of the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"ct_state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"direction"),(0,r.kt)("td",{parentName:"tr",align:null},"Direction of the packet relative to the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"ct_dir")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"status"),(0,r.kt)("td",{parentName:"tr",align:null},"Status of the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"ct_status")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mark"),(0,r.kt)("td",{parentName:"tr",align:null},"Connection mark"),(0,r.kt)("td",{parentName:"tr",align:null},"mark")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expiration"),(0,r.kt)("td",{parentName:"tr",align:null},"Connection expiration time"),(0,r.kt)("td",{parentName:"tr",align:null},"time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"helper"),(0,r.kt)("td",{parentName:"tr",align:null},"Helper associated with the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"label"),(0,r.kt)("td",{parentName:"tr",align:null},"Connection tracking label bit or symbolic name defined in connlabel.conf in the nftables include path"),(0,r.kt)("td",{parentName:"tr",align:null},"ct_label")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"l3proto"),(0,r.kt)("td",{parentName:"tr",align:null},"Layer 3 protocol of the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"nf_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"saddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Source address of the connection for the given direction"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr/ipv6_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"daddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Destination address of the connection for the given direction"),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr/ipv6_addr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"Layer 4 protocol of the connection for the given direction"),(0,r.kt)("td",{parentName:"tr",align:null},"inet_proto")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"proto-src"),(0,r.kt)("td",{parentName:"tr",align:null},"Layer 4 protocol source for the given direction"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"proto-dst"),(0,r.kt)("td",{parentName:"tr",align:null},"Layer 4 protocol destination for the given direction"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"packets"),(0,r.kt)("td",{parentName:"tr",align:null},"packet count seen in the given direction or sum of original and reply"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"bytecount seen, see description for ",(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"packets"))," keyword"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"avgpkt"),(0,r.kt)("td",{parentName:"tr",align:null},"average bytes per packet, see description for ",(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"packets"))," keyword"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (64 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"zone"),(0,r.kt)("td",{parentName:"tr",align:null},"conntrack zone"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("h2",{id:"statements"},"Statements"),(0,r.kt)("p",null,"Statements represent actions to be performed. They can alter control flow (return, jump to a different chain, accept or drop the packet) or can perform actions, such as logging, rejecting a packet, etc."),(0,r.kt)("p",null,"Statements exist in two kinds. Terminal statements unconditionally terminate evaluation of the current rule, non-terminal statements either only conditionally or never terminate evaluation of the current rule, in other words, they are passive from the ruleset evaluation perspective. There can be an arbitrary amount of non-terminal statements in a rule, but only a single terminal statement as the final statement."),(0,r.kt)("h3",{id:"verdict-statement"},"Verdict statement"),(0,r.kt)("p",null,"The verdict statement alters control flow in the ruleset and issues policy decisions for packets."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{accept | drop | queue | continue | return}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{jump | goto} {chain}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"accept")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Terminate ruleset evaluation and accept the packet.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"drop")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Terminate ruleset evaluation and drop the packet.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"queue")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Terminate ruleset evaluation and queue the packet to userspace.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"continue")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Continue ruleset evaluation with the next rule. FIXME")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"return")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Return from the current chain and continue evaluation at the next rule in the last chain. If issued in a base chain, it is equivalent to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"accept")),".")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"jump chain")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Continue evaluation at the first rule in chain. The current position in the ruleset is pushed to a call stack and evaluation will continue there when the new chain is entirely evaluated of a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"return"))," verdict is issued.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"goto chain")),(0,r.kt)("dd",null,(0,r.kt)("p",null,"Similar to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"jump")),", but the current position is not pushed to the call stack, meaning that after the new chain evaluation will continue at the last chain instead of the one containing the goto statement.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 16. Verdict statements"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# process packets from eth0 and the internal network in from_lan\n# chain, drop all packets from eth0 with different source addresses.\n\nfilter input iif eth0 ip saddr 192.168.0.0/24 jump from_lan\nfilter input iif eth0 drop\n")),(0,r.kt)("h3",{id:"payload-statement"},"Payload statement"),(0,r.kt)("p",null,"The payload statement alters packet content. It can be used for example to set ip DSCP (differv) header field or ipv6 flow labels."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 17. route some packets instead of bridging"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# redirect tcp:http from 192.160.0.0/16 to local machine for routing instead of bridging\n# assumes 00:11:22:33:44:55 is local MAC address.\nbridge input meta iif eth0 ip saddr 192.168.0.0/16 tcp dport 80 meta pkttype set unicast ether daddr set 00:11:22:33:44:55\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 18. Set IPv4 DSCP header field"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ip forward ip dscp set 42\n")),(0,r.kt)("h3",{id:"log-statement"},"Log statement"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"log [prefix _quoted_string_] [level _syslog-level_] [flags log-flags]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"log [group _nflog_group_] [prefix _quoted_string_] [queue-threshold value] [snaplen size]")),(0,r.kt)("p",null,"The log statement enables logging of matching packets. When this statement is used from a rule, the Linux kernel will print some information on all matching packets, such as header fields, via the kernel log (where it can be read with dmesg(1) or read in the syslog). If the group number is specified, the Linux kernel will pass the packet to nfnetlink_log which will multicast the packet through a netlink socket to the specified multicast group. One or more userspace processes may subscribe to the group to receive the packets, see libnetfilter_queue documentation for details. This is a non-terminating statement, so the rule evaluation continues after the packet is logged."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 45. log statement options"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"prefix"),(0,r.kt)("td",{parentName:"tr",align:null},"Log message prefix"),(0,r.kt)("td",{parentName:"tr",align:null},"quoted string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"syslog-level"),(0,r.kt)("td",{parentName:"tr",align:null},"Syslog level of logging"),(0,r.kt)("td",{parentName:"tr",align:null},"string: emerg, alert, crit, err, warn ","[default]",", notice, info, debug")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"group"),(0,r.kt)("td",{parentName:"tr",align:null},"NFLOG group to send messages to"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"snaplen"),(0,r.kt)("td",{parentName:"tr",align:null},"Length of packet payload to include in netlink message"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"queue-threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of packets to queue inside the kernel before sending them to userspace"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (32 bit)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 46. log-flags"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Flag"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tcp sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"Log TCP sequence numbers.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tcp options"),(0,r.kt)("td",{parentName:"tr",align:null},"Log options from the TCP packet header.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip options"),(0,r.kt)("td",{parentName:"tr",align:null},"Log options from the IP/IPv6 packet header.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skuid"),(0,r.kt)("td",{parentName:"tr",align:null},"Log the userid of the process which generated the packet.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ether"),(0,r.kt)("td",{parentName:"tr",align:null},"Decode MAC addresses and protocol.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"all"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable all log flags listed above.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 19. Using log statement"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# log the UID which generated the packet and ip options\nip filter output log flags skuid flags ip options\n\n# log the tcp sequence numbers and tcp options from the TCP packet\nip filter output log flags tcp sequence,options\n\n# enable all supported log flags\nip6 filter output log flags all\n")),(0,r.kt)("h3",{id:"reject-statement"},"Reject statement"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"reject [with] {icmp | icmp6 | icmpx} [type] {icmp_type | icmp6_type | icmpx_type}")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"reject [with] {tcp} {reset}")),(0,r.kt)("p",null,"A reject statement is used to send back an error packet in response to the matched packet otherwise it is equivalent to drop so it is a terminating statement, ending rule traversal. This statement is only valid in the input, forward and output chains, and user-defined chains which are only called from those chains."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 47. reject statement type (ip)"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"icmp_type"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMP type response to be sent to the host"),(0,r.kt)("td",{parentName:"tr",align:null},"net-unreachable, host-unreachable, prot-unreachable, port-unreachable ","[default]",", net-prohibited, host-prohibited, admin-prohibited")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 48. reject statement type (ip6)"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"icmp6_type"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMPv6 type response to be sent to the host"),(0,r.kt)("td",{parentName:"tr",align:null},"no-route, admin-prohibited, addr-unreachable, port-unreachable ","[default]",", policy-fail, reject-route")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 49. reject statement type (inet)"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"icmpx_type"),(0,r.kt)("td",{parentName:"tr",align:null},"ICMPvXtype abstraction response to be sent to the host, this is a set of types that overlap in IPv4 and IPv6 to be used from the inet family."),(0,r.kt)("td",{parentName:"tr",align:null},"port-unreachable ","[default]",", admin-prohibited, no-route, host-unreachable")))),(0,r.kt)("h3",{id:"counter-statement"},"Counter statement"),(0,r.kt)("p",null,"A counter statement sets the hit count of packets along with the number of bytes."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"counter {packets _number_ } {bytes _number_ }")),(0,r.kt)("h3",{id:"conntrack-statement"},"Conntrack statement"),(0,r.kt)("p",null,"The conntrack statement can be used to set the conntrack mark and conntrack labels."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ct {mark | eventmask | label | zone} [set] value")),(0,r.kt)("p",null,"The ct statement sets meta data associated with a connection. The zone id has to be assigned before a conntrack lookup takes place, i.e. this has to be done in prerouting and possibly output (if locally generated packets need to be placed in a distinct zone), with a hook priority of -300."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 50. Conntrack statement types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eventmask"),(0,r.kt)("td",{parentName:"tr",align:null},"conntrack event bits"),(0,r.kt)("td",{parentName:"tr",align:null},"bitmask, integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"helper"),(0,r.kt)("td",{parentName:"tr",align:null},"name of ct helper object to assign to the connection"),(0,r.kt)("td",{parentName:"tr",align:null},"quoted string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mark"),(0,r.kt)("td",{parentName:"tr",align:null},"Connection tracking mark"),(0,r.kt)("td",{parentName:"tr",align:null},"mark")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"label"),(0,r.kt)("td",{parentName:"tr",align:null},"Connection tracking label"),(0,r.kt)("td",{parentName:"tr",align:null},"label")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"zone"),(0,r.kt)("td",{parentName:"tr",align:null},"conntrack zone"),(0,r.kt)("td",{parentName:"tr",align:null},"integer (16 bit)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 20. save packet nfmark in conntrack"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ct mark set meta mark\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 21. set zone mapped via interface"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'table inet raw {\n  chain prerouting {\n      type filter hook prerouting priority -300;\n      ct zone set iif map { "eth1" : 1, "veth1" : 2 }\n  }\n  chain output {\n      type filter hook output priority -300;\n      ct zone set oif map { "eth1" : 1, "veth1" : 2 }\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 22. restrict events reported by ctnetlink"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ct eventmask set new or related or destroy\n")),(0,r.kt)("h3",{id:"meta-statement"},"Meta statement"),(0,r.kt)("p",null,"A meta statement sets the value of a meta expression. The existing meta fields are: priority, mark, pkttype, nftrace."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"meta {mark | priority | pkttype | nftrace} [set] value")),(0,r.kt)("p",null,"A meta statement sets meta data associated with a packet."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 51. Meta statement types"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"priority"),(0,r.kt)("td",{parentName:"tr",align:null},"TC packet priority"),(0,r.kt)("td",{parentName:"tr",align:null},"tc_handle")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mark"),(0,r.kt)("td",{parentName:"tr",align:null},"Packet mark"),(0,r.kt)("td",{parentName:"tr",align:null},"mark")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pkttype"),(0,r.kt)("td",{parentName:"tr",align:null},"packet type"),(0,r.kt)("td",{parentName:"tr",align:null},"pkt_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nftrace"),(0,r.kt)("td",{parentName:"tr",align:null},"ruleset packet tracing on/off. Use ",(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"monitor trace"))," command to watch traces"),(0,r.kt)("td",{parentName:"tr",align:null},"0, 1")))),(0,r.kt)("h3",{id:"limit-statement"},"Limit statement"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"limit [rate] [over]_packet_number_ [/] {second | minute | hour | day} [burst _packet_number_ packets]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"limit [rate] [over]_byte_number_ {bytes | kbytes | mbytes} [/] {second | minute | hour | day | week} [burst _byte_number_ bytes]")),(0,r.kt)("p",null,"A limit statement matches at a limited rate using a token bucket filter. A rule using this statement will match until this limit is reached. It can be used in combination with the log statement to give limited logging. The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"over"))," keyword, that is optional, makes it match over the specified rate."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 52. limit statement values"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"packet_number"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of packets"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (32 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"byte_number"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (32 bit)")))),(0,r.kt)("h3",{id:"nat-statements"},"NAT statements"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"snat [to _address_ [:port]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"snat [to _address_ - _address_ [:_port_ - _port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dnat [to _address_ [:_port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dnat [to _address_ [:_port_ - _port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"masquerade [to [:_port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"masquerade [to [:_port_ - _port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"redirect [to [:_port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"redirect [to [:_port_ - _port_]] [persistent, random, fully-random]")),(0,r.kt)("p",null,"The nat statements are only valid from nat chain types."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"snat"))," and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"masquerade"))," statements specify that the source address of the packet should be modified. While ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"snat"))," is only valid in the postrouting and input chains, ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"masquerade"))," makes sense only in postrouting. The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"dnat"))," and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"redirect"))," statements are only valid in the prerouting and output chains, they specify that the destination address of the packet should be modified. You can use non-base chains which are called from base chains of nat chain type too. All future packets in this connection will also be mangled, and rules should cease being examined."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"masquerade"))," statement is a special form of ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"snat"))," which always uses the outgoing interface's IP address to translate to. It is particularly useful on gateways with dynamic (public) IP addresses."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"redirect"))," statement is a special form of ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"dnat"))," which always translates the destination address to the local host's one. It comes in handy if one only wants to alter the destination port of incoming traffic on different interfaces."),(0,r.kt)("p",null,"Note that all nat statements require both prerouting and postrouting base chains to be present since otherwise packets on the return path won't be seen by netfilter and therefore no reverse translation will take place."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 53. NAT statement values"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Expression"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"address"),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies that the source/destination address of the packet should be modified. You may specify a mapping to relate a list of tuples composed of arbitrary expression key with address value."),(0,r.kt)("td",{parentName:"tr",align:null},"ipv4_addr, ipv6_addr, eg. abcd::1234, or you can use a mapping, eg. meta mark map { 10 : 192.168.1.2, 20 : 192.168.1.3 }")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"port"),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies that the source/destination address of the packet should be modified."),(0,r.kt)("td",{parentName:"tr",align:null},"port number (16 bits)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 54. NAT statement flags"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Flag"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"persistent"),(0,r.kt)("td",{parentName:"tr",align:null},"Gives a client the same source-/destination-address for each connection.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"random"),(0,r.kt)("td",{parentName:"tr",align:null},"If used then port mapping will be randomized using a random seeded MD5 hash mix using source and destination address and destination port.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fully-random"),(0,r.kt)("td",{parentName:"tr",align:null},"If used then port mapping is generated based on a 32-bit pseudo-random algorithm.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 23. Using NAT statements"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# create a suitable table/chain setup for all further examples\nadd table nat\nadd chain nat prerouting { type nat hook prerouting priority 0; }\nadd chain nat postrouting { type nat hook postrouting priority 100; }\n\n# translate source addresses of all packets leaving via eth0 to address 1.2.3.4\nadd rule nat postrouting oif eth0 snat to 1.2.3.4\n\n# redirect all traffic entering via eth0 to destination address 192.168.1.120\nadd rule nat prerouting iif eth0 dnat to 192.168.1.120\n\n# translate source addresses of all packets leaving via eth0 to whatever\n# locally generated packets would use as source to reach the same destination\nadd rule nat postrouting oif eth0 masquerade\n\n# redirect incoming TCP traffic for port 22 to port 2222\nadd rule nat prerouting tcp dport 22 redirect to :2222\n")),(0,r.kt)("h3",{id:"queue-statement"},"Queue statement"),(0,r.kt)("p",null,"This statement passes the packet to userspace using the nfnetlink_queue handler. The packet is put into the queue identified by its 16-bit queue number. Userspace can inspect and modify the packet if desired. Userspace must then drop or reinject the packet into the kernel. See libnetfilter_queue documentation for details."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"queue [num _queue_number_] [bypass]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"queue [num _queue_number_from_ - _queue_number_to_] [bypass,fanout]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 55. queue statement values"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"queue_number"),(0,r.kt)("td",{parentName:"tr",align:null},"Sets queue number, default is 0."),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"queue_number_from"),(0,r.kt)("td",{parentName:"tr",align:null},"Sets initial queue in the range, if fanout is used."),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (16 bit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"queue_number_to"),(0,r.kt)("td",{parentName:"tr",align:null},"Sets closing queue in the range, if fanout is used."),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned integer (16 bit)")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Table 56. queue statement flags"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Flag"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bypass"),(0,r.kt)("td",{parentName:"tr",align:null},"Let packets go through if userspace application cannot back off. Before using this flag, read libnetfilter_queue documentation for performance tuning recomendations.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fanout"),(0,r.kt)("td",{parentName:"tr",align:null},"Distribute packets between several queues.")))),(0,r.kt)("h2",{id:"additional-commands"},"Additional commands"),(0,r.kt)("p",null,"These are some additional commands included in nft."),(0,r.kt)("h3",{id:"export"},"export"),(0,r.kt)("p",null,"Export your current ruleset in XML or JSON format to stdout."),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[...]\n% nft export json\n[...]\n")),(0,r.kt)("h3",{id:"monitor"},"monitor"),(0,r.kt)("p",null,"The monitor command allows you to listen to Netlink events produced by the nf_tables subsystem, related to creation and deletion of objects. When they ocurr, nft will print to stdout the monitored events in either XML, JSON or native nft format."),(0,r.kt)("p",null,"To filter events related to a concrete object, use one of the keywords 'tables', 'chains', 'sets', 'rules', 'elements'."),(0,r.kt)("p",null,"To filter events related to a concrete action, use keyword 'new' or 'destroy'."),(0,r.kt)("p",null,"Hit ^C to finish the monitor operation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 24. Listen to all events, report in native nft format"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"% nft monitor\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 25. Listen to added tables, report in XML format"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"% nft monitor new tables xml\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 26. Listen to deleted rules, report in JSON format"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"% nft monitor destroy rules json\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 27. Listen to both new and destroyed chains, in native nft format"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"% nft monitor chains\n")),(0,r.kt)("h2",{id:"error-reporting"},"Error reporting"),(0,r.kt)("p",null,"When an error is detected, nft shows the line(s) containing the error, the position of the erroneous parts in the input stream and marks up the erroneous parts using carrets (^). If the error results from the combination of two expressions or statements, the part imposing the constraints which are violated is marked using tildes (~)."),(0,r.kt)("p",null,"For errors returned by the kernel, nft can't detect which parts of the input caused the error and the entire command is marked."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 28. Error caused by single incorrect expression"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<cmdline>:1:19-22: Error: Interface does not exist\nfilter output oif eth0\n                  ^^^^\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 29. Error caused by invalid combination of two expressions"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<cmdline>:1:28-36: Error: Right hand side of relational expression (==) must be constant\nfilter output tcp dport == tcp dport\n                        ~~ ^^^^^^^^^\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\u793a\u4f8b 30. Error returned by the kernel"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<cmdline>:0:0-23: Error: Could not process rule: Operation not permitted\nfilter output oif wlan0\n^^^^^^^^^^^^^^^^^^^^^^^\n")),(0,r.kt)("h2",{id:"\u9000\u51fa\u72b6\u6001\u7801"},"\u9000\u51fa\u72b6\u6001\u7801"),(0,r.kt)("p",null,"On success, nft exits with a status of 0. Unspecified errors cause it to exit with a status of 1, memory allocation errors with a status of 2, unable to open Netlink socket with 3."),(0,r.kt)("h2",{id:"see-also"},"See Also"),(0,r.kt)("p",null,"iptables(8), ip6tables(8), arptables(8), ebtables(8), ip(8), tc(8)"),(0,r.kt)("p",null,"There is an official wiki at: ",(0,r.kt)("a",{parentName:"p",href:"http://wiki.nftables.org"},"wiki.nftables.org")),(0,r.kt)("h2",{id:"authors"},"Authors"),(0,r.kt)("p",null,"nftables was written by Patrick McHardy and Pablo Neira Ayuso, among many other contributors from the Netfilter community."),(0,r.kt)("h2",{id:"copyright"},"Copyright"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Copyright\xa0\xa9\xa02008-2014\xa0Patrick\xa0McHardy\xa0",(0,r.kt)("a",{parentName:"li",href:"mailto:%5Bkaber@trash.net%5D(mailto:kaber@trash.net)"},"[kaber@trash.net](mailto:kaber@trash.net)")),(0,r.kt)("li",{parentName:"ul"},"Copyright\xa0\xa9\xa02013-2016\xa0Pablo\xa0Neira\xa0Ayuso\xa0",(0,r.kt)("a",{parentName:"li",href:"mailto:%5Bpablo@netfilter.org%5D(mailto:pablo@netfilter.org)"},"[pablo@netfilter.org](mailto:pablo@netfilter.org)"))),(0,r.kt)("p",null,"nftables is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"This documentation is licenced under the terms of the Creative Commons Attribution-ShareAlike 4.0 license, ",(0,r.kt)("a",{parentName:"em",href:"http://creativecommons.org/licenses/by-sa/4.0/"},"CC BY-SA 4.0"),"."))))}k.isMDXComponent=!0}}]);